#include <iostream>
#include <iomanip>
#include <cfloat>
#include <sycl/sycl.hpp>

using namespace sycl;

float input[] = { 
  1.001, 1.002, 1.003, 1.004, 1.005, 1.006, 1.007, 1.008, 1.009,
  1.01 , 1.011, 1.012, 1.013, 1.014, 1.015, 1.016, 1.017, 1.018,
  1.019, 1.02 , 1.021, 1.022, 1.023, 1.024, 1.025, 1.026, 1.027,
  1.028, 1.029, 1.03 , 1.031, 1.032, 1.033, 1.034, 1.035, 1.036,
  1.037, 1.038, 1.039, 1.04 , 1.041, 1.042, 1.043, 1.044, 1.045,
  1.046, 1.047, 1.048, 1.049, 1.05 , 1.051, 1.052, 1.053, 1.054,
  1.055, 1.056, 1.057, 1.058, 1.059, 1.06 , 1.061, 1.062, 1.063,
  1.064, 1.065, 1.066, 1.067, 1.068, 1.069, 1.07 , 1.071, 1.072,
  1.073, 1.074, 1.075, 1.076, 1.077, 1.078, 1.079, 1.08 , 1.081,
  1.082, 1.083, 1.084, 1.085, 1.086, 1.087, 1.088, 1.089, 1.09 ,
  1.091, 1.092, 1.093, 1.094, 1.095, 1.096, 1.097, 1.098, 1.099,
  1.1  , 1.101, 1.102, 1.103, 1.104, 1.105, 1.106, 1.107, 1.108,
  1.109, 1.11 , 1.111, 1.112, 1.113, 1.114, 1.115, 1.116, 1.117,
  1.118, 1.119, 1.12 , 1.121, 1.122, 1.123, 1.124, 1.125, 1.126,
  1.127, 1.128,
  3.001, 3.002, 3.003, 3.004, 3.005, 3.006, 3.007, 3.008, 3.009,
  3.01 , 3.011, 3.012, 3.013, 3.014, 3.015, 3.016, 3.017, 3.018,
  3.019, 3.02 , 3.021, 3.022, 3.023, 3.024, 3.025, 3.026, 3.027,
  3.028, 3.029, 3.03 , 3.031, 3.032, 3.033, 3.034, 3.035, 3.036,
  3.037, 3.038, 3.039, 3.04 , 3.041, 3.042, 3.043, 3.044, 3.045,
  3.046, 3.047, 3.048, 3.049, 3.05 , 3.051, 3.052, 3.053, 3.054,
  3.055, 3.056, 3.057, 3.058, 3.059, 3.06 , 3.061, 3.062, 3.063,
  3.064, 3.065, 3.066, 3.067, 3.068, 3.069, 3.07 , 3.071, 3.072,
  3.073, 3.074, 3.075, 3.076, 3.077, 3.078, 3.079, 3.08 , 3.081,
  3.082, 3.083, 3.084, 3.085, 3.086, 3.087, 3.088, 3.089, 3.09 ,
  3.091, 3.092, 3.093, 3.094, 3.095, 3.096, 3.097, 3.098, 3.099,
  3.1  , 3.101, 3.102, 3.103, 3.104, 3.105, 3.106, 3.107, 3.108,
  3.109, 3.11 , 3.111, 3.112, 3.113, 3.114, 3.115, 3.116, 3.117,
  3.118, 3.119, 3.12 , 3.121, 3.122, 3.123, 3.124, 3.125, 3.126,
  3.127, 3.128,
  5.001, 5.002, 5.003, 5.004, 5.005, 5.006, 5.007, 5.008, 5.009,
  5.01 , 5.011, 5.012, 5.013, 5.014, 5.015, 5.016, 5.017, 5.018,
  5.019, 5.02 , 5.021, 5.022, 5.023, 5.024, 5.025, 5.026, 5.027,
  5.028, 5.029, 5.03 , 5.031, 5.032, 5.033, 5.034, 5.035, 5.036,
  5.037, 5.038, 5.039, 5.04 , 5.041, 5.042, 5.043, 5.044, 5.045,
  5.046, 5.047, 5.048, 5.049, 5.05 , 5.051, 5.052, 5.053, 5.054,
  5.055, 5.056, 5.057, 5.058, 5.059, 5.06 , 5.061, 5.062, 5.063,
  5.064, 5.065, 5.066, 5.067, 5.068, 5.069, 5.07 , 5.071, 5.072,
  5.073, 5.074, 5.075, 5.076, 5.077, 5.078, 5.079, 5.08 , 5.081,
  5.082, 5.083, 5.084, 5.085, 5.086, 5.087, 5.088, 5.089, 5.09 ,
  5.091, 5.092, 5.093, 5.094, 5.095, 5.096, 5.097, 5.098, 5.099,
  5.1  , 5.101, 5.102, 5.103, 5.104, 5.105, 5.106, 5.107, 5.108,
  5.109, 5.11 , 5.111, 5.112, 5.113, 5.114, 5.115, 5.116, 5.117,
  5.118, 5.119, 5.12 , 5.121, 5.122, 5.123, 5.124, 5.125, 5.126,
  5.127, 5.128,
  7.001, 7.002, 7.003, 7.004, 7.005, 7.006, 7.007, 7.008, 7.009,
  7.01 , 7.011, 7.012, 7.013, 7.014, 7.015, 7.016, 7.017, 7.018,
  7.019, 7.02 , 7.021, 7.022, 7.023, 7.024, 7.025, 7.026, 7.027,
  7.028, 7.029, 7.03 , 7.031, 7.032, 7.033, 7.034, 7.035, 7.036,
  7.037, 7.038, 7.039, 7.04 , 7.041, 7.042, 7.043, 7.044, 7.045,
  7.046, 7.047, 7.048, 7.049, 7.05 , 7.051, 7.052, 7.053, 7.054,
  7.055, 7.056, 7.057, 7.058, 7.059, 7.06 , 7.061, 7.062, 7.063,
  7.064, 7.065, 7.066, 7.067, 7.068, 7.069, 7.07 , 7.071, 7.072,
  7.073, 7.074, 7.075, 7.076, 7.077, 7.078, 7.079, 7.08 , 7.081,
  7.082, 7.083, 7.084, 7.085, 7.086, 7.087, 7.088, 7.089, 7.09 ,
  7.091, 7.092, 7.093, 7.094, 7.095, 7.096, 7.097, 7.098, 7.099,
  7.1  , 7.101, 7.102, 7.103, 7.104, 7.105, 7.106, 7.107, 7.108,
  7.109, 7.11 , 7.111, 7.112, 7.113, 7.114, 7.115, 7.116, 7.117,
  7.118, 7.119, 7.12 , 7.121, 7.122, 7.123, 7.124, 7.125, 7.126,
  7.127, 7.128,
};

#define ROWS 4
#define COLS 128

#define SG_SZ 32
#define SHM_SIZE 2048

void print_and_validate(float *output);

int main(int argc, char **argv) {
    sycl::queue q({property::queue::in_order(), property::queue::enable_profiling()});

    sycl::range<3> global(1, 1, 256);
    sycl::range<3> local(1, 1, 256);
    sycl::nd_range<3> ndrange(global, local);

    float * dev_in = (float *)malloc_device(sizeof(float) * ROWS * COLS, q);
    q.memcpy(dev_in, input, sizeof(float) * ROWS * COLS).wait();
    auto pIn = multi_ptr<float, sycl::access::address_space::global_space>(dev_in);

    float* output = (float*)malloc(sizeof(float) * COLS);
    float * dev_out = (float *)malloc_device(sizeof(float) * COLS, q);

    q.submit([&](auto &cgh) {
        sycl::stream out(65536, 256, cgh);
        using share_mem_t = sycl::accessor<float, 1, sycl::access::mode::read_write, sycl::access::target::local>;
        share_mem_t scratch = share_mem_t(ROWS*COLS, cgh);

        cgh.parallel_for(ndrange, 
                         [=](nd_item<3> item)[[intel::reqd_sub_group_size(SG_SZ)]] {
                            int16_t threadIdx = item.get_local_id(2);
                            int16_t idx_4 = threadIdx << 1;
                            int16_t idx_5 = idx_4 & (int16_t)126;
                            int16_t idx_8 = idx_4 & (int16_t)384;

                            int32_t scratch_idx_6 = threadIdx << 1;
                            int32_t scratch_idx_16 = scratch_idx_6 & 510;
                            int64_t scratch_idx_17 = (int64_t)scratch_idx_16;

                            int64_t idx = idx_5 + idx_8;

                            // // float *base = dev_in + (int64_t)(idx_8);
                            // // float *addr = base + (int64_t)idx_5;
                            float2 vec2;
                            vec2.load(idx/2, pIn);
                            float val = vec2[0];


                            scratch[scratch_idx_17] = val;
                            item.barrier(sycl::access::fence_space::local_space);
                            val = scratch[scratch_idx_17];
                            if (threadIdx < 64) {
                              *(dev_out+(int64_t)idx_8+(int64_t)idx_5) = val;
                                out << "thread: " << threadIdx << " ---> input[" << idx << "] = " << val << ")\n";
                            }
                         });
    }).wait();
    q.memcpy(output, dev_out, sizeof(float) * COLS).wait();
    print_and_validate(output);

    free(output);
}


void print_and_validate(float *output) {
  std::cout << "Output: \n";
  for(int col = 0; col < COLS; col++ ) {
    std::cout << std::setw(5) << output[col];
    if ((col+1) % 32 == 0) {
      std::cout << std::endl;
    } else {
      std::cout << " ";
    }
  }
  std::cout << std::endl;

  std::cout << "Row Index: \n";
  for (int col = 0; col < COLS; col++) {
    int row = 0;
    for (row = 0; row < ROWS; row++) {
      if (input[row * COLS + col] == output[col]) break;
    }
    std::cout << std::setw(3) << row;
    if ((col + 1) % 32 == 0) {
      std::cout << std::endl;
    } else {
      std::cout << " ";
    }
  }
  std::cout << std::endl;

  std::cout << "Wrong Index: \n";
  for (int col = 0; col < COLS; col++) {
    float max = FLT_MIN;
    for (int row = 0; row < ROWS; row++) {
      max = std::max<float>(max, input[row * COLS + col]);
    }
    if (max != output[col]) std::cout << std::setw(3) << col << " ";
  }
  std::cout << std::endl;
}
